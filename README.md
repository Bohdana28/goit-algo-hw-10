# goit-algo-hw-10
# Домашнє завдання 1 — Видача решти

## Жадібний алгоритм
Жадібний алгоритм бере найбільшу доступну монету та віднімає її від суми, доки не набере потрібну величину.
- Часова складність: **O(k)**, де *k* — кількість різних монет.
- Переваги: дуже швидкий, працює для великих сум.
- Недоліки: не завжди гарантує мінімальну кількість монет (залежить від набору номіналів).

## Динамічне програмування
Алгоритм динамічного програмування перевіряє всі варіанти формування суми та зберігає мінімальну кількість монет для кожної проміжної суми.
- Часова складність: **O(n·k)**, де *n* — сума, *k* — кількість монет.
- Переваги: завжди знаходить оптимальне рішення.
- Недоліки: повільніший при дуже великих сумах, споживає більше пам’яті.

---

## Приклади

### Набір монет `[50, 25, 10, 5, 2, 1]`
Сума: **113**

- Greedy → `{50: 2, 10: 1, 2: 1, 1: 1}`
- DP → `{50: 2, 10: 1, 2: 1, 1: 1}`

У цьому випадку обидва алгоритми дають однаковий результат.

---

### Набір монет `[9, 6, 1]`
Сума: **12**

- Greedy → `{9: 1, 1: 3}` (всього **4 монети**)
- DP → `{6: 2}` (всього **2 монети**, оптимально)

Тут видно, що жадібний алгоритм помилився.

---

## Висновки
- Для класичних наборів монет (як у гривнях, доларах чи євро) жадібний алгоритм працює добре та дуже швидко.
- Для нестандартних наборів монет жадібний може дати неоптимальне рішення.
- Динамічне програмування завжди знаходить мінімальну кількість монет, проте працює повільніше для великих сум.